-- File generated by the BNF Converter (bnfc 2.9.5).

{-# LANGUAGE CPP #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE LambdaCase #-}
#if __GLASGOW_HASKELL__ <= 708
{-# LANGUAGE OverlappingInstances #-}
#endif

-- | Pretty-printer for Print.

module Print where

import Prelude
  ( ($), (.)
  , Bool(..), (==), (<)
  , Int, Integer, Double, (*)
  , String, (++)
  , Show, ShowS, show, showChar, showString
  , all, elem, foldr, id, map, null, replicate, shows, span
  )

import Control.Unification (UTerm(..))
import Control.Unification.IntVar (IntVar(..))
import Data.Char ( Char, isSpace )
import Data.List (intercalate)
import Data.Maybe

import qualified Grammar

-- | The top-level printing method.

printTree :: Print a => a -> String
printTree = render . prt 0

type Doc = [ShowS] -> [ShowS]

doc :: ShowS -> Doc
doc = (:)

render :: Doc -> String
render d = rend 0 False (map ($ "") $ d []) ""
  where
  rend
    :: Int        -- ^ Indentation level.
    -> Bool       -- ^ Pending indentation to be output before next character?
    -> [String]
    -> ShowS
  rend i p = \case
      "["      :ts -> char '[' . rend i False ts
      "("      :ts -> char '(' . rend i False ts
      "{"      :ts -> char '{' . rend i False ts
      "}"      :ts -> char '}' . rend i False ts
      ";"      :ts -> showString "; " . rend i False ts
      t  : ts@(s:_) | closingOrPunctuation s
                   -> pending . showString t . rend i False ts
      t        :ts -> pending . space t      . rend i False ts
      []           -> id
    where
    -- Output character after pending indentation.
    char :: Char -> ShowS
    char c = pending . showChar c

    -- Output pending indentation.
    pending :: ShowS
    pending = if p then indent i else id

  -- Indentation (spaces) for given indentation level.
  indent :: Int -> ShowS
  indent i = replicateS (2*i) (showChar ' ')

  -- Continue rendering in new line with new indentation.
  -- new :: Int -> [String] -> ShowS
  -- new j ts = showChar '\n' . rend j True ts

  -- Make sure we are on a fresh line.
  -- onNewLine :: Int -> Bool -> ShowS
  -- onNewLine i p = (if p then id else showChar '\n') . indent i

  -- Separate given string from following text by a space (if needed).
  space :: String -> ShowS
  space t s =
    case (all isSpace t, null spc, null rest) of
      (True , _   , True ) -> []             -- remove trailing space
      (False, _   , True ) -> t              -- remove trailing space
      (False, True, False) -> t ++ ' ' : s   -- add space if none
      _                    -> t ++ s
    where
      (spc, rest) = span isSpace s

  closingOrPunctuation :: String -> Bool
  closingOrPunctuation [c] = c `elem` closerOrPunct
  closingOrPunctuation _   = False

  closerOrPunct :: String
  closerOrPunct = ")],;"

parenth :: Doc -> Doc
parenth ss = doc (showChar '(') . ss . doc (showChar ')')

concatS :: [ShowS] -> ShowS
concatS = foldr (.) id

concatD :: [Doc] -> Doc
concatD = foldr (.) id

replicateS :: Int -> ShowS -> ShowS
replicateS n f = concatS (replicate n f)

-- | The printer class does the job.

class Print a where
  prt :: Int -> a -> Doc

instance {-# OVERLAPPABLE #-} Print a => Print [a] where
  prt i = concatD . map (prt i)

instance Print Char where
  prt _ c = doc (showChar '\'' . mkEsc '\'' c . showChar '\'')

instance Print String where
  prt _ = printString

printString :: String -> Doc
printString s = doc (showChar '"' . concatS (map (mkEsc '"') s) . showChar '"')

mkEsc :: Char -> Char -> ShowS
mkEsc q = \case
  s | s == q -> showChar '\\' . showChar s
  '\\' -> showString "\\\\"
  '\n' -> showString "\\n"
  '\t' -> showString "\\t"
  s -> showChar s

prPrec :: Int -> Int -> Doc -> Doc
prPrec i j = if j < i then parenth else id

instance Print Integer where
  prt _ x = doc (shows x)

instance Print Double where
  prt _ x = doc (shows x)

instance Print Grammar.Prefix where
  prt _ (Grammar.Prefix i) = doc $ showString i
instance Print Grammar.InfixHash where
  prt _ (Grammar.InfixHash i) = doc $ showString i
instance Print Grammar.InfixShift where
  prt _ (Grammar.InfixShift i) = doc $ showString i
instance Print Grammar.InfixMultiply where
  prt _ (Grammar.InfixMultiply i) = doc $ showString i
instance Print Grammar.InfixAdd where
  prt _ (Grammar.InfixAdd i) = doc $ showString i
instance Print Grammar.InfixAt where
  prt _ (Grammar.InfixAt i) = doc $ showString i
instance Print Grammar.InfixCompare where
  prt _ (Grammar.InfixCompare i) = doc $ showString i
instance Print Grammar.InfixAnd where
  prt _ (Grammar.InfixAnd i) = doc $ showString i
instance Print Grammar.InfixOr where
  prt _ (Grammar.InfixOr i) = doc $ showString i
instance Print Grammar.InfixAssignRef where
  prt _ (Grammar.InfixAssignRef i) = doc $ showString i
instance Print Grammar.DirectiveIdent where
  prt _ (Grammar.DirectiveIdent i) = doc $ showString i
instance Print Grammar.UppercaseIdent where
  prt _ (Grammar.UppercaseIdent i) = doc $ showString i
instance Print Grammar.LowercaseIdent where
  prt _ (Grammar.LowercaseIdent i) = doc $ showString i
instance Print (Grammar.Infix' a) where
  prt i = \case
    Grammar.OpOr _ infixor -> prPrec i 0 (concatD [prt 0 infixor])
    Grammar.OpAnd _ infixand -> prPrec i 0 (concatD [prt 0 infixand])
    Grammar.OpCompare _ infixcompare -> prPrec i 0 (concatD [prt 0 infixcompare])
    Grammar.OpAt _ infixat -> prPrec i 0 (concatD [prt 0 infixat])
    Grammar.OpAppend _ -> prPrec i 0 (concatD [doc (showString "::")])
    Grammar.OpAdd _ infixadd -> prPrec i 0 (concatD [prt 0 infixadd])
    Grammar.OpSubInt _ -> prPrec i 0 (concatD [doc (showString "-")])
    Grammar.OpSubFloat _ -> prPrec i 0 (concatD [doc (showString "-.")])
    Grammar.OpMul _ infixmultiply -> prPrec i 0 (concatD [prt 0 infixmultiply])
    Grammar.OpMulInt _ -> prPrec i 0 (concatD [doc (showString "*")])
    Grammar.OpShift _ infixshift -> prPrec i 0 (concatD [prt 0 infixshift])
    Grammar.OpHash _ infixhash -> prPrec i 0 (concatD [prt 0 infixhash])
    Grammar.OpAssignRef _ infixassignref -> prPrec i 0 (concatD [prt 0 infixassignref])

instance Print (Grammar.Constant' a) where
  prt i = \case
    Grammar.CInteger _ n -> prPrec i 0 (concatD [prt 0 n])
    Grammar.CDouble _ d -> prPrec i 0 (concatD [prt 0 d])
    Grammar.CChar _ c -> prPrec i 0 (concatD [prt 0 c])
    Grammar.CString _ str -> prPrec i 0 (concatD [printString str])
    Grammar.CFalse _ -> prPrec i 0 (concatD [doc (showString "false")])
    Grammar.CTrue _ -> prPrec i 0 (concatD [doc (showString "true")])
    Grammar.CUnit1 _ -> prPrec i 0 (concatD [doc (showString "()")])
    Grammar.CUnit2 _ -> prPrec i 0 (concatD [doc (showString "("), doc (showString ")")])
    Grammar.CBegin _ -> prPrec i 0 (concatD [doc (showString "begin"), doc (showString "end")])
    Grammar.CConstructor _ oidents -> prPrec i 0 (concatD [prt 0 oidents])
    Grammar.CFun _ -> prPrec i 0 (concatD [doc (showString "<fun>")])

instance Print (Grammar.ForToDownTo' a) where
  prt i = \case
    Grammar.ForTo _ -> prPrec i 0 (concatD [doc (showString "to")])
    Grammar.ForDownTo _ -> prPrec i 0 (concatD [doc (showString "downto")])

instance Print (Grammar.RecOptional' a) where
  prt i = \case
    Grammar.RecNo _ -> prPrec i 0 (concatD [])
    Grammar.RecYes _ -> prPrec i 0 (concatD [doc (showString "rec")])

instance Show a => Print (Grammar.Expr' a) where
  prt i = \case
    Grammar.Variable _ oidents -> prPrec i 23 (concatD [prt 0 oidents])
    Grammar.VCanonical _ (Grammar.CanonicalField field) -> prPrec i 23 (concatD [prt 0 field])
    Grammar.VCanonical _ name -> prPrec i 23 (concatD [doc . showString . intercalate "/" . map printTree $ (Grammar.to name :: Grammar.Path)])
    Grammar.TIdent _ oident -> prPrec i 23 (concatD [doc (showString $ "'" ++ printTree oident)])
    Grammar.Blank _ -> prPrec i 23 (concatD [doc (showString "_")])
    Grammar.EConstant _ constant -> prPrec i 23 (concatD [prt 0 constant])
    Grammar.Record _ fields -> prPrec i 23 (concatD [doc (showString "{"), prt 0 fields, doc (showString "}")])
    Grammar.List _ exprs -> prPrec i 23 (concatD [doc (showString "["), prt 2 exprs, doc (showString "]")])
    Grammar.Nil1 _ -> prPrec i 23 (concatD [doc (showString "["), doc (showString "]")])
    Grammar.Nil2 _ -> prPrec i 23 (concatD [doc (showString "[]")])
    Grammar.EBegin _ expr -> prPrec i 22 (concatD [doc (showString "begin"), prt 0 expr, doc (showString "end")])
    Grammar.EWhile _ expr1 expr2 -> prPrec i 22 (concatD [doc (showString "while"), prt 0 expr1, doc (showString "do"), prt 0 expr2, doc (showString "done")])
    Grammar.EFor _ expr1 fortodownto expr2 expr3 -> prPrec i 22 (concatD [doc (showString "for"), prt 0 expr1, prt 0 fortodownto, prt 0 expr2, doc (showString "do"), prt 0 expr3, doc (showString "done")])
    Grammar.EPrefix _ prefix expr -> prPrec i 21 (concatD [prt 0 prefix, prt 21 expr])
    Grammar.EHash _ expr1 infixhash expr2 -> prPrec i 19 (concatD [prt 19 expr1, prt 0 infixhash, prt 20 expr2])
    Grammar.EApply _ expr exprs -> prPrec i 17 (concatD [prt 18 expr, prt 18 exprs])
    Grammar.EConstructor _ expr1 expr2 -> prPrec i 17 (concatD [prt 23 expr1, prt 18 expr2])
    Grammar.TPolymorphic _ expr1 expr2 -> prPrec i 17 (concatD [prt 17 expr1, prt 23 expr2])
    Grammar.ENegateInt _ expr -> prPrec i 16 (concatD [doc (showString "-"), prt 17 expr])
    Grammar.ENegateFloat _ expr -> prPrec i 16 (concatD [doc (showString "-."), prt 17 expr])
    Grammar.EShift _ expr1 infixshift expr2 -> prPrec i 15 (concatD [prt 16 expr1, prt 0 infixshift, prt 15 expr2])
    Grammar.EMultiply _ expr1 infixmultiply expr2 -> prPrec i 14 (concatD [prt 14 expr1, prt 0 infixmultiply, prt 15 expr2])
    Grammar.TTuple _ expr exprs -> prPrec i 14 (concatD [prt 15 expr, doc (showString "*"), prt 15 exprs])
    Grammar.EAdd _ expr1 infixadd expr2 -> prPrec i 13 (concatD [prt 13 expr1, prt 0 infixadd, prt 14 expr2])
    Grammar.ESubInt _ expr1 expr2 -> prPrec i 13 (concatD [prt 13 expr1, doc (showString "-"), prt 14 expr2])
    Grammar.ESubFloat _ expr1 expr2 -> prPrec i 13 (concatD [prt 13 expr1, doc (showString "-."), prt 14 expr2])
    Grammar.EAppend _ expr1 expr2 -> prPrec i 12 (concatD [prt 13 expr1, doc (showString "::"), prt 12 expr2])
    Grammar.EAt _ expr1 infixat expr2 -> prPrec i 11 (concatD [prt 12 expr1, prt 0 infixat, prt 11 expr2])
    Grammar.ECompare _ expr1 infixcompare expr2 -> prPrec i 10 (concatD [prt 10 expr1, prt 0 infixcompare, prt 11 expr2])
    Grammar.EAnd _ expr1 infixand expr2 -> prPrec i 9 (concatD [prt 10 expr1, prt 0 infixand, prt 9 expr2])
    Grammar.EOr _ expr1 infixor expr2 -> prPrec i 8 (concatD [prt 9 expr1, prt 0 infixor, prt 8 expr2])
    Grammar.ETuple _ expr exprs -> prPrec i 7 (concatD [prt 8 expr, doc (showString ","), prt 8 exprs])
    Grammar.TParams _ exprs -> prPrec i 7 (concatD [prt 8 exprs])
    Grammar.EAssignRef _ expr1 infixassignref expr2 -> prPrec i 6 (concatD [prt 7 expr1, prt 0 infixassignref, prt 6 expr2])
    Grammar.EAssign _ expr1 expr2 -> prPrec i 6 (concatD [prt 7 expr1, doc (showString "<-"), prt 6 expr2])
    Grammar.EIf _ expr1 expr2 -> prPrec i 5 (concatD [doc (showString "if"), prt 6 expr1, doc (showString "then"), prt 6 expr2])
    Grammar.EIfElse _ expr1 expr2 expr3 -> prPrec i 5 (concatD [doc (showString "if"), prt 6 expr1, doc (showString "then"), prt 6 expr2, doc (showString "else"), prt 5 expr3])
    Grammar.TFunction _ expr1 expr2 -> prPrec i 4 (concatD [prt 5 expr1, doc (showString "->"), prt 4 expr2])
    Grammar.ConstrOf _ expr1 expr2 -> prPrec i 3 (concatD [prt 23 expr1, doc (showString "of"), prt 4 expr2])
    Grammar.ETyped _ expr1 expr2 -> prPrec i 3 (concatD [prt 17 expr1, doc (showString ":"), prt 4 expr2])
    Grammar.ConstrOr _ expr exprs -> prPrec i 2 (concatD [prt 3 expr, doc (showString "|"), prt 3 exprs])
    Grammar.ESeq _ expr exprs -> prPrec i 1 (concatD [prt 2 expr, doc (showString ";"), prt 2 exprs])
    Grammar.ModuleSignature _ toplevel -> prPrec i 1 (concatD [doc (showString "sig"), prt 0 toplevel, doc (showString "end")])
    Grammar.ModuleDefinition _ toplevel -> prPrec i 1 (concatD [doc (showString "struct"), prt 0 toplevel, doc (showString "end")])
    Grammar.ELambda _ function exprs expr -> prPrec i 1 (concatD [prt 0 function, prt 18 exprs, doc (showString "->"), prt 0 expr])
    Grammar.ELambdaTyped _ function exprs expr1 expr2 -> prPrec i 1 (concatD [prt 0 function, prt 18 exprs, doc (showString ":"), prt 5 expr1, doc (showString "->"), prt 0 expr2])
    Grammar.LetPattern _ expr1 expr2 -> prPrec i 1 (concatD [prt 2 expr1, doc (showString "="), prt 0 expr2])
    Grammar.EMatch _ expr patternprefixoptional exprs -> prPrec i 1 (concatD [doc (showString "match"), prt 0 expr, doc (showString "with"), prt 0 patternprefixoptional, prt 3 exprs])
    Grammar.ETryWith _ expr patternprefixoptional exprs -> prPrec i 1 (concatD [doc (showString "try"), prt 0 expr, doc (showString "with"), prt 0 patternprefixoptional, prt 3 exprs])
    Grammar.ELetIn _ recoptional exprs expr -> prPrec i 0 (concatD [doc (showString "let"), prt 0 recoptional, prt 1 exprs, doc (showString "in"), prt 0 expr])
    other -> \e -> [shows other] 

instance Show a => Print [Grammar.Field' a] where
  prt _ [] = concatD []
  prt _ [x] = concatD [prt 0 x]
  prt _ (x:xs) = concatD [prt 0 x, doc (showString ";"), prt 0 xs]

instance Show a => Print (Grammar.Field' a) where
  prt i = \case
    Grammar.EField _ expr1 expr2 -> prPrec i 0 (concatD [prt 23 expr1, doc (showString "="), prt 2 expr2])
    Grammar.EFieldDecl _ expr1 expr2 -> prPrec i 0 (concatD [prt 23 expr1, doc (showString ":"), prt 4 expr2])
    Grammar.EFieldDeclMut _ expr1 expr2 -> prPrec i 0 (concatD [doc (showString "mutable"), prt 23 expr1, doc (showString ":"), prt 4 expr2])

instance Show a => Print [Grammar.Expr' a] where
  prt _ [] = concatD []
  prt 18 [x] = concatD [prt 18 x, doc (showString " ")]
  prt 18 (x:xs) = concatD [prt 18 x, doc (showString " "), prt 18 xs]
  prt 15 [x] = concatD [prt 15 x]
  prt 15 (x:xs) = concatD [prt 15 x, doc (showString "*"), prt 15 xs]
  prt 8 [x] = concatD [prt 8 x]
  prt 8 (x:xs) = concatD [prt 8 x, doc (showString ","), prt 8 xs]
  prt 3 [x] = concatD [prt 3 x]
  prt 3 (x:xs) = concatD [prt 3 x, doc (showString "|"), prt 3 xs]
  prt 2 [x] = concatD [prt 2 x]
  prt 2 (x:xs) = concatD [prt 2 x, doc (showString ";"), prt 2 xs]
  prt _ [x] = concatD [prt 1 x]
  prt _ (x:xs) = concatD [prt 1 x, doc (showString "and"), prt 1 xs]

instance Print (Grammar.Function' a) where
  prt i = \case
    Grammar.Fun1 _ -> prPrec i 0 (concatD [doc (showString "fun")])
    Grammar.Fun2 _ -> prPrec i 0 (concatD [doc (showString "function")])

instance Print (Grammar.PatternPrefixOptional' a) where
  prt i = \case
    Grammar.PatternPrefixNo _ -> prPrec i 0 (concatD [])
    Grammar.PatternPrefixYes _ -> prPrec i 0 (concatD [doc (showString "|")])

instance Show a => Print [Grammar.Statement' a] where
  prt _ [] = concatD []
  prt _ (x:xs) = concatD [prt 0 x, prt 0 xs]

instance Show a => Print (Grammar.Statement' a) where
  prt i = \case
    Grammar.Signature _ expr -> prPrec i 0 (concatD [doc (showString "val"), prt 3 expr])
    Grammar.External _ expr -> prPrec i 0 (concatD [doc (showString "external"), prt 1 expr])
    Grammar.Typedef _ expr patternprefixoptional exprs -> prPrec i 0 (concatD [doc (showString "type"), prt 4 expr, doc (showString "="), prt 0 patternprefixoptional, prt 3 exprs])
    Grammar.Exception _ expr -> prPrec i 0 (concatD [doc (showString "exception"), prt 3 expr])
    Grammar.Module _ expr -> prPrec i 0 (concatD [doc (showString "module"), prt 1 expr])
    Grammar.ModuleType _ expr -> prPrec i 0 (concatD [doc (showString "module"), doc (showString "type"), prt 1 expr])
    Grammar.Definition _ recoptional exprs -> prPrec i 0 (concatD [doc (showString "let"), prt 0 recoptional, prt 1 exprs])
    Grammar.SLetIn _ recoptional exprs expr -> prPrec i 0 (concatD [doc (showString "let"), prt 0 recoptional, prt 1 exprs, doc (showString "in"), prt 0 expr])
    Grammar.Expression _ expr -> prPrec i 0 (concatD [doc (showString ";;"), prt 1 expr])
    Grammar.Directive1 _ oident expr -> prPrec i 0 (concatD [doc (showString "#"), prt 0 oident, prt 17 expr])
    Grammar.Directive2 _ directiveident expr -> prPrec i 0 (concatD [prt 0 directiveident, prt 17 expr])
    Grammar.EndStmt _ statement -> prPrec i 0 (concatD [prt 0 statement, doc (showString ";;")])

instance Show a => Print (Grammar.Toplevel' a) where
  prt i = \case
    Grammar.Toplevel1 _ statements -> prPrec i 0 (concatD [prt 0 statements])
    Grammar.Toplevel2 _ expr statements -> prPrec i 0 (concatD [prt 1 expr, prt 0 statements])

instance Print [Grammar.OIdent' a] where
  prt _ [] = concatD []
  prt _ [x] = concatD [prt 0 x]
  prt _ (x:xs) = concatD [prt 0 x, doc (showString "."), prt 0 xs]

instance Print (Grammar.OIdent' a) where
  prt i = \case
    Grammar.IUppercase _ uppercaseident -> prPrec i 0 (concatD [prt 0 uppercaseident])
    Grammar.ILowercase _ lowercaseident -> prPrec i 0 (concatD [prt 0 lowercaseident])
    Grammar.IPrefix _ prefix -> prPrec i 0 (concatD [doc (showString "("), prt 0 prefix, doc (showString ")")])
    Grammar.IInfix _ infix_ -> prPrec i 0 (concatD [doc (showString "("), prt 0 infix_, doc (showString ")")])
    Grammar.IVer _ n -> prPrec i 0 (concatD [doc (showString $ "v." ++ show n)])

instance Print (Grammar.Tag) where
  prt i = \case
    Grammar.TagModule -> prPrec i 0 (concatD [doc (showString "<module>")])
    Grammar.TagType -> prPrec i 0 (concatD [doc (showString "<type>")])
    Grammar.TagExpression -> prPrec i 0 (concatD [doc (showString "<expression>")])
    Grammar.TagPattern -> prPrec i 0 (concatD [doc (showString "<pattern>")])

instance Print (Grammar.NameContext) where
  prt i = \case
    Grammar.CtxDeclaration -> prPrec i 0 (concatD [doc (showString "<declaration>")])
    Grammar.CtxGlobal -> prPrec i 0 (concatD [doc (showString "<global_definition>")])
    Grammar.CtxLocal -> prPrec i 0 (concatD [doc (showString "<local_definition>")])
    Grammar.CtxUsage -> prPrec i 0 (concatD [doc (showString "<usage>")])

instance Print IntVar where
  prt i = \case
    IntVar iv -> prPrec i 0 (concatD [doc (showString (show iv))])

instance Show a => Print (UTerm Grammar.Term a) where
  prt i = \case
    UVar v -> prPrec i 0 (concatD [doc (showString (show v))])
    UTerm t -> prPrec i 0 (concatD [doc (showString (show t))])

instance Print Grammar.BNFC'Position where
  prt i = \case
    Nothing -> id
    Just (path, line, col) -> prPrec i 0 (concatD [doc (showString $ path ++ ":" ++ show line ++ ":" ++ show col)])