-- File generated by the BNF Converter (bnfc 2.9.5).
{-# LANGUAGE DeriveTraversable #-}
{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE PatternSynonyms #-}
{-# LANGUAGE StrictData #-}
{-# LANGUAGE UndecidableInstances #-}

-- | The abstract syntax of language ocaml.
module Grammar where

import qualified Data.String
import Prelude
  ( Char
  , Double
  , Integer
  , String
  , ($)
  , (++)
  , (.)
  , (<$>)
  , (>>=)
  , error
  , id
  , map
  , return
  , undefined
  )
import qualified Prelude as C
  ( Eq
  , Foldable(..)
  , Functor(..)
  , IO
  , Int
  , Maybe(..)
  , Ord(..)
  , Read(..)
  , Show(..)
  , Traversable(..)
  )

import Control.Monad (mapM)
import Control.Unification (UTerm(..))
import Control.Unification.IntVar (IntVar(..))
import Data.IORef
import qualified Data.Map as Map
import System.FilePath
import System.IO.Unsafe (unsafePerformIO)

type Path = [OIdent]

instance C.Ord a => C.Ord (IORef a) where
  compare x y =
    C.compare (unsafePerformIO $ readIORef x) (unsafePerformIO $ readIORef y)

instance C.Read (IORef a) where
  readsPrec = undefined

instance C.Read IntVar where
  readsPrec = undefined

data FileSystem k v t
  = Directory (Map.Map k (IORef (FileSystem k v t))) t
  | File v t
  deriving (C.Eq, C.Ord, C.Read)

type TypedStorage v = IORef (FileSystem OIdent v IntVar)

type Storage v = IORef (FileSystem OIdent v ())

type Memory = TypedStorage Expr

fromIODeep :: Memory -> C.IO Expr
fromIODeep fs = do
  fs' <- readIORef fs
  case fs' of
    File v t -> return v
    Directory m _ ->
      Record npos
        <$> mapM
              (\(ILowercase _ k, v) ->
                 EField npos (VCanonical npos $ CanonicalField k)
                   <$> fromIODeep v)
              (Map.toList m)

instance C.Show Memory where
  show x = C.show . unsafePerformIO $ (fromIODeep x :: C.IO Expr)

data CanonicalName
  = CanonicalName
      { nametag :: Tag
      , moduleidents :: [UppercaseIdent]
      , nameident :: OIdent
      , nameversion :: Integer
      , recordidents :: [LowercaseIdent]
      }
  | CanonicalModule [UppercaseIdent]
  | CanonicalField LowercaseIdent
  deriving (C.Eq, C.Ord, C.Show, C.Read)

identField :: UppercaseIdent
identField = UppercaseIdent ".field"

-- Check https://hackage.haskell.org/package/type-iso-1.0.1.0
class Iso a b where
  to :: a -> b
  from :: b -> a

instance Iso CanonicalName Path where
  from = undefined
  to =
    \case
      CanonicalName t m n v r ->
        map (IUppercase npos) m ++ [n, IVer npos v] ++ map (ILowercase npos) r
      CanonicalModule m -> map (IUppercase npos) m
      CanonicalField i -> [IUppercase npos identField, ILowercase npos i]

data Term a
  = TermVariable Path
  | TermTuple [a]
  | TermPolymorphic a a
  | TermFunction a a
  | TermParams [a]
  deriving (C.Show, C.Ord, C.Eq, C.Foldable, C.Functor, C.Traversable)

type OpenTerm = UTerm Term IntVar

instance C.Ord IntVar where
  IntVar v1 <= IntVar v2 = v1 C.<= v2

type Infix = Infix' BNFC'Position

data Infix' a
  = OpOr a InfixOr
  | OpAnd a InfixAnd
  | OpCompare a InfixCompare
  | OpAt a InfixAt
  | OpAppend a
  | OpAdd a InfixAdd
  | OpSubInt a
  | OpSubFloat a
  | OpMul a InfixMultiply
  | OpMulInt a
  | OpShift a InfixShift
  | OpHash a InfixHash
  | OpAssignRef a InfixAssignRef
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable)

type Constant = Constant' BNFC'Position

data Constant' a
  = CInteger a Integer
  | CDouble a Double
  | CChar a Char
  | CString a String
  | CFalse a
  | CTrue a
  | CUnit1 a
  | CUnit2 a
  | CBegin a
  | CConstructor a [OIdent' a]
  | CFun a
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable)

type ForToDownTo = ForToDownTo' BNFC'Position

data ForToDownTo' a
  = ForTo a
  | ForDownTo a
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable)

type RecOptional = RecOptional' BNFC'Position

data RecOptional' a
  = RecNo a
  | RecYes a
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable)

type Expr = Expr' BNFC'Position

data Expr' a
  = Variable a [OIdent' a]
  | VCanonical a CanonicalName
  | Reference Memory
  | TIdent a (OIdent' a)
  | Blank a
  | EConstant a (Constant' a)
  | Record a [Field' a]
  | List a [Expr' a]
  | Nil1 a
  | Nil2 a
  | EBegin a (Expr' a)
  | EWhile a (Expr' a) (Expr' a)
  | EFor a (Expr' a) (ForToDownTo' a) (Expr' a) (Expr' a)
  | EPrefix a Prefix (Expr' a)
  | EHash a (Expr' a) InfixHash (Expr' a)
  | EApply a (Expr' a) [Expr' a]
  | EConstructor a (Expr' a) (Expr' a)
  | TPolymorphic a (Expr' a) (Expr' a)
  | ENegateInt a (Expr' a)
  | ENegateFloat a (Expr' a)
  | EShift a (Expr' a) InfixShift (Expr' a)
  | EMultiply a (Expr' a) InfixMultiply (Expr' a)
  | TTuple a (Expr' a) [Expr' a]
  | EAdd a (Expr' a) InfixAdd (Expr' a)
  | ESubInt a (Expr' a) (Expr' a)
  | ESubFloat a (Expr' a) (Expr' a)
  | EAppend a (Expr' a) (Expr' a)
  | EAt a (Expr' a) InfixAt (Expr' a)
  | ECompare a (Expr' a) InfixCompare (Expr' a)
  | EAnd a (Expr' a) InfixAnd (Expr' a)
  | EOr a (Expr' a) InfixOr (Expr' a)
  | ETuple a (Expr' a) [Expr' a]
  | TParams a [Expr' a]
  | EAssignRef a (Expr' a) InfixAssignRef (Expr' a)
  | EAssign a (Expr' a) (Expr' a)
  | EIf a (Expr' a) (Expr' a)
  | EIfElse a (Expr' a) (Expr' a) (Expr' a)
  | TFunction a (Expr' a) (Expr' a)
  | ConstrOf a (Expr' a) (Expr' a)
  | ETyped a (Expr' a) (Expr' a)
  | ConstrOr a (Expr' a) [Expr' a]
  | ESeq a (Expr' a) [Expr' a]
  | ModuleSignature a (Toplevel' a)
  | ModuleDefinition a (Toplevel' a)
  | EPartial [Expr] [Expr] Expr
  | ELambda a (Function' a) [Expr' a] (Expr' a)
  | EExternalLambda String Expr [Expr]
  | ELambdaTyped a (Function' a) [Expr' a] (Expr' a) (Expr' a)
  | LetPattern a (Expr' a) (Expr' a)
  | EMatch a (Expr' a) (PatternPrefixOptional' a) [Expr' a]
  | ETryWith a (Expr' a) (PatternPrefixOptional' a) [Expr' a]
  | ELetIn a (RecOptional' a) [Expr' a] (Expr' a)
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable)

type Field = Field' BNFC'Position

data Field' a
  = EField a (Expr' a) (Expr' a)
  | EFieldDecl a (Expr' a) (Expr' a)
  | EFieldDeclMut a (Expr' a) (Expr' a)
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable)

type Function = Function' BNFC'Position

data Function' a
  = Fun1 a
  | Fun2 a
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable)

type PatternPrefixOptional = PatternPrefixOptional' BNFC'Position

data PatternPrefixOptional' a
  = PatternPrefixNo a
  | PatternPrefixYes a
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable)

type Statement = Statement' BNFC'Position

data Statement' a
  = Signature a (Expr' a)
  | External a (Expr' a)
  | Typedef a (Expr' a) (PatternPrefixOptional' a) [Expr' a]
  | Exception a (Expr' a)
  | Module a (Expr' a)
  | ModuleType a (Expr' a)
  | Definition a (RecOptional' a) [Expr' a]
  | SLetIn a (RecOptional' a) [Expr' a] (Expr' a)
  | Expression a (Expr' a)
  | Directive1 a (OIdent' a) (Expr' a)
  | Directive2 a DirectiveIdent (Expr' a)
  | EndStmt a (Statement' a)
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable)

type Toplevel = Toplevel' BNFC'Position

data Toplevel' a
  = Toplevel1 a [Statement' a]
  | Toplevel2 a (Expr' a) [Statement' a]
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable)

type OIdent = OIdent' BNFC'Position

data OIdent' a
  = IUppercase a UppercaseIdent
  | ILowercase a LowercaseIdent
  | IPrefix a Prefix
  | IInfix a (Infix' a)
  | IVer a Integer
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable)

data Tag
  = TagModule
  | TagType
  | TagExpression
  | TagPattern
  deriving (C.Eq, C.Ord, C.Show, C.Read)

data NameContext
  = CtxDeclaration
  | CtxGlobal
  | CtxLocal
  | CtxUsage
  deriving (C.Eq, C.Ord, C.Show, C.Read)

newtype Prefix =
  Prefix String
  deriving (C.Eq, C.Ord, C.Show, C.Read, Data.String.IsString)

newtype InfixHash =
  InfixHash String
  deriving (C.Eq, C.Ord, C.Show, C.Read, Data.String.IsString)

newtype InfixShift =
  InfixShift String
  deriving (C.Eq, C.Ord, C.Show, C.Read, Data.String.IsString)

newtype InfixMultiply =
  InfixMultiply String
  deriving (C.Eq, C.Ord, C.Show, C.Read, Data.String.IsString)

newtype InfixAdd =
  InfixAdd String
  deriving (C.Eq, C.Ord, C.Show, C.Read, Data.String.IsString)

newtype InfixAt =
  InfixAt String
  deriving (C.Eq, C.Ord, C.Show, C.Read, Data.String.IsString)

newtype InfixCompare =
  InfixCompare String
  deriving (C.Eq, C.Ord, C.Show, C.Read, Data.String.IsString)

newtype InfixAnd =
  InfixAnd String
  deriving (C.Eq, C.Ord, C.Show, C.Read, Data.String.IsString)

newtype InfixOr =
  InfixOr String
  deriving (C.Eq, C.Ord, C.Show, C.Read, Data.String.IsString)

newtype InfixAssignRef =
  InfixAssignRef String
  deriving (C.Eq, C.Ord, C.Show, C.Read, Data.String.IsString)

newtype DirectiveIdent =
  DirectiveIdent String
  deriving (C.Eq, C.Ord, C.Show, C.Read, Data.String.IsString)

newtype UppercaseIdent =
  UppercaseIdent String
  deriving (C.Eq, C.Ord, C.Show, C.Read, Data.String.IsString)

newtype LowercaseIdent =
  LowercaseIdent String
  deriving (C.Eq, C.Ord, C.Show, C.Read, Data.String.IsString)

-- | Start position (line, column) of something.
type BNFC'Position = C.Maybe (FilePath, C.Int, C.Int)

pattern BNFC'NoPosition :: BNFC'Position
pattern BNFC'NoPosition = C.Nothing

npos :: BNFC'Position
npos = BNFC'NoPosition

pattern BNFC'Position :: C.Int -> C.Int -> BNFC'Position
pattern BNFC'Position line col = C.Just ("", line, col)

-- | Get the start position of something.
class HasPosition a where
  hasPosition :: a -> BNFC'Position
  stripPosition :: a -> a
  stripPosition = id

instance HasPosition Infix where
  hasPosition =
    \case
      OpOr p _ -> p
      OpAnd p _ -> p
      OpCompare p _ -> p
      OpAt p _ -> p
      OpAppend p -> p
      OpAdd p _ -> p
      OpSubInt p -> p
      OpSubFloat p -> p
      OpMul p _ -> p
      OpMulInt p -> p
      OpShift p _ -> p
      OpHash p _ -> p
      OpAssignRef p _ -> p
  stripPosition =
    \case
      OpOr _ x -> OpOr npos x
      OpAnd _ x -> OpAnd npos x
      OpCompare _ x -> OpCompare npos x
      OpAt _ x -> OpAt npos x
      OpAppend _ -> OpAppend npos
      OpAdd _ x -> OpAdd npos x
      OpSubInt _ -> OpSubInt npos
      OpSubFloat _ -> OpSubFloat npos
      OpMul _ x -> OpMul npos x
      OpMulInt _ -> OpMulInt npos
      OpShift _ x -> OpShift npos x
      OpHash _ x -> OpHash npos x
      OpAssignRef _ x -> OpAssignRef npos x

instance HasPosition Constant where
  hasPosition =
    \case
      CInteger p _ -> p
      CDouble p _ -> p
      CChar p _ -> p
      CString p _ -> p
      CFalse p -> p
      CTrue p -> p
      CUnit1 p -> p
      CUnit2 p -> p
      CBegin p -> p
      CConstructor p _ -> p
      CFun p -> p
  stripPosition =
    \case
      CInteger _ i -> CInteger npos i
      CDouble _ d -> CDouble npos d
      CChar _ c -> CChar npos c
      CString _ s -> CString npos s
      CFalse _ -> CFalse npos
      CTrue _ -> CTrue npos
      CUnit1 _ -> CUnit1 npos
      CUnit2 _ -> CUnit2 npos
      CBegin _ -> CBegin npos
      CFun _ -> CFun npos

instance HasPosition ForToDownTo where
  hasPosition =
    \case
      ForTo p -> p
      ForDownTo p -> p

instance HasPosition RecOptional where
  hasPosition =
    \case
      RecNo p -> p
      RecYes p -> p

instance HasPosition Expr where
  hasPosition =
    \case
      Variable p _ -> p
      TIdent p _ -> p
      Blank p -> p
      EConstant p _ -> p
      Record p _ -> p
      List p _ -> p
      Nil1 p -> p
      Nil2 p -> p
      EBegin p _ -> p
      EWhile p _ _ -> p
      EFor p _ _ _ _ -> p
      EPrefix p _ _ -> p
      EHash p _ _ _ -> p
      EApply p _ _ -> p
      EConstructor p _ _ -> p
      TPolymorphic p _ _ -> p
      ENegateInt p _ -> p
      ENegateFloat p _ -> p
      EShift p _ _ _ -> p
      EMultiply p _ _ _ -> p
      TTuple p _ _ -> p
      EAdd p _ _ _ -> p
      ESubInt p _ _ -> p
      ESubFloat p _ _ -> p
      EAppend p _ _ -> p
      EAt p _ _ _ -> p
      ECompare p _ _ _ -> p
      EAnd p _ _ _ -> p
      EOr p _ _ _ -> p
      ETuple p _ _ -> p
      TParams p _ -> p
      EAssignRef p _ _ _ -> p
      EAssign p _ _ -> p
      EIf p _ _ -> p
      EIfElse p _ _ _ -> p
      TFunction p _ _ -> p
      ConstrOf p _ _ -> p
      ETyped p _ _ -> p
      ConstrOr p _ _ -> p
      ESeq p _ _ -> p
      ModuleSignature p _ -> p
      ModuleDefinition p _ -> p
      ELambda p _ _ _ -> p
      ELambdaTyped p _ _ _ _ -> p
      LetPattern p _ _ -> p
      EMatch p _ _ _ -> p
      ETryWith p _ _ _ -> p
      ELetIn p _ _ _ -> p
  stripPosition =
    \case
      Variable _ v -> Variable npos $ map stripPosition v
      EConstant _ c -> EConstant npos $ stripPosition c
      other -> other

instance HasPosition Field where
  hasPosition =
    \case
      EField p _ _ -> p
      EFieldDecl p _ _ -> p
      EFieldDeclMut p _ _ -> p

instance HasPosition Function where
  hasPosition =
    \case
      Fun1 p -> p
      Fun2 p -> p

instance HasPosition PatternPrefixOptional where
  hasPosition =
    \case
      PatternPrefixNo p -> p
      PatternPrefixYes p -> p

instance HasPosition Statement where
  hasPosition =
    \case
      Signature p _ -> p
      External p _ -> p
      Typedef p _ _ _ -> p
      Exception p _ -> p
      Module p _ -> p
      ModuleType p _ -> p
      Definition p _ _ -> p
      SLetIn p _ _ _ -> p
      Expression p _ -> p
      Directive1 p _ _ -> p
      Directive2 p _ _ -> p
      EndStmt p _ -> p

instance HasPosition Toplevel where
  hasPosition =
    \case
      Toplevel1 p _ -> p
      Toplevel2 p _ _ -> p

instance HasPosition OIdent where
  hasPosition =
    \case
      IUppercase p _ -> p
      ILowercase p _ -> p
      IPrefix p _ -> p
      IInfix p _ -> p
      IVer p _ -> p
  stripPosition =
    \case
      IUppercase _ x -> IUppercase npos x
      ILowercase _ x -> ILowercase npos x
      IPrefix _ x -> IPrefix npos x
      IInfix _ x -> IInfix npos $ stripPosition x
      IVer _ v -> IVer npos v
