-- -*- haskell -*- File generated by the BNF Converter (bnfc 2.9.5).

-- Parser definition for use with Happy
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
{-# LANGUAGE PatternSynonyms #-}

module Parser
  ( happyError
  , myLexer
  , pToplevel
  ) where

import Prelude

import qualified Grammar
import Lexer

}

%name pToplevel_internal Toplevel
-- no lexer declaration
%monad { Err } { (>>=) } { return }
%tokentype {Token}
%token
  '#'              { PT _ (TS _ 1)             }
  '\''             { PT _ (TS _ 2)             }
  '('              { PT _ (TS _ 3)             }
  '()'             { PT _ (TS _ 4)             }
  ')'              { PT _ (TS _ 5)             }
  '*'              { PT _ (TS _ 6)             }
  ','              { PT _ (TS _ 7)             }
  '-'              { PT _ (TS _ 8)             }
  '-.'             { PT _ (TS _ 9)             }
  '->'             { PT _ (TS _ 10)            }
  '.'              { PT _ (TS _ 11)            }
  ':'              { PT _ (TS _ 12)            }
  '::'             { PT _ (TS _ 13)            }
  ';'              { PT _ (TS _ 14)            }
  ';;'             { PT _ (TS _ 15)            }
  '<-'             { PT _ (TS _ 16)            }
  '='              { PT _ (TS _ 17)            }
  '['              { PT _ (TS _ 18)            }
  '[]'             { PT _ (TS _ 19)            }
  ']'              { PT _ (TS _ 20)            }
  '_'              { PT _ (TS _ 21)            }
  'and'            { PT _ (TS _ 22)            }
  'begin'          { PT _ (TS _ 23)            }
  'do'             { PT _ (TS _ 24)            }
  'done'           { PT _ (TS _ 25)            }
  'downto'         { PT _ (TS _ 26)            }
  'else'           { PT _ (TS _ 27)            }
  'end'            { PT _ (TS _ 28)            }
  'exception'      { PT _ (TS _ 29)            }
  'external'       { PT _ (TS _ 30)            }
  'false'          { PT _ (TS _ 31)            }
  'for'            { PT _ (TS _ 32)            }
  'fun'            { PT _ (TS _ 33)            }
  'function'       { PT _ (TS _ 34)            }
  'if'             { PT _ (TS _ 35)            }
  'in'             { PT _ (TS _ 36)            }
  'let'            { PT _ (TS _ 37)            }
  'match'          { PT _ (TS _ 38)            }
  'module'         { PT _ (TS _ 39)            }
  'mutable'        { PT _ (TS _ 40)            }
  'of'             { PT _ (TS _ 41)            }
  'rec'            { PT _ (TS _ 42)            }
  'sig'            { PT _ (TS _ 43)            }
  'struct'         { PT _ (TS _ 44)            }
  'then'           { PT _ (TS _ 45)            }
  'to'             { PT _ (TS _ 46)            }
  'true'           { PT _ (TS _ 47)            }
  'try'            { PT _ (TS _ 48)            }
  'type'           { PT _ (TS _ 49)            }
  'val'            { PT _ (TS _ 50)            }
  'while'          { PT _ (TS _ 51)            }
  'with'           { PT _ (TS _ 52)            }
  '{'              { PT _ (TS _ 53)            }
  '|'              { PT _ (TS _ 54)            }
  '}'              { PT _ (TS _ 55)            }
  L_charac         { PT _ (TC _)               }
  L_doubl          { PT _ (TD _)               }
  L_integ          { PT _ (TI _)               }
  L_quoted         { PT _ (TL _)               }
  L_Prefix         { PT _ (T_Prefix _)         }
  L_InfixHash      { PT _ (T_InfixHash _)      }
  L_InfixShift     { PT _ (T_InfixShift _)     }
  L_InfixMultiply  { PT _ (T_InfixMultiply _)  }
  L_InfixAdd       { PT _ (T_InfixAdd _)       }
  L_InfixAt        { PT _ (T_InfixAt _)        }
  L_InfixCompare   { PT _ (T_InfixCompare _)   }
  L_InfixAnd       { PT _ (T_InfixAnd _)       }
  L_InfixOr        { PT _ (T_InfixOr _)        }
  L_InfixAssignRef { PT _ (T_InfixAssignRef _) }
  L_DirectiveIdent { PT _ (T_DirectiveIdent _) }
  L_UppercaseIdent { PT _ (T_UppercaseIdent _) }
  L_LowercaseIdent { PT _ (T_LowercaseIdent _) }

%%

Char    :: { (Grammar.BNFC'Position, Char) }
Char     : L_charac { (uncurry Grammar.BNFC'Position (tokenLineCol $1), (read (tokenText $1)) :: Char) }

Double  :: { (Grammar.BNFC'Position, Double) }
Double   : L_doubl  { (uncurry Grammar.BNFC'Position (tokenLineCol $1), (read (tokenText $1)) :: Double) }

Integer :: { (Grammar.BNFC'Position, Integer) }
Integer  : L_integ  { (uncurry Grammar.BNFC'Position (tokenLineCol $1), (read (tokenText $1)) :: Integer) }

String  :: { (Grammar.BNFC'Position, String) }
String   : L_quoted { (uncurry Grammar.BNFC'Position (tokenLineCol $1), ((\(PT _ (TL s)) -> s) $1)) }

Prefix :: { (Grammar.BNFC'Position, Grammar.Prefix) }
Prefix  : L_Prefix { (uncurry Grammar.BNFC'Position (tokenLineCol $1), Grammar.Prefix (tokenText $1)) }

InfixHash :: { (Grammar.BNFC'Position, Grammar.InfixHash) }
InfixHash  : L_InfixHash { (uncurry Grammar.BNFC'Position (tokenLineCol $1), Grammar.InfixHash (tokenText $1)) }

InfixShift :: { (Grammar.BNFC'Position, Grammar.InfixShift) }
InfixShift  : L_InfixShift { (uncurry Grammar.BNFC'Position (tokenLineCol $1), Grammar.InfixShift (tokenText $1)) }

InfixMultiply :: { (Grammar.BNFC'Position, Grammar.InfixMultiply) }
InfixMultiply  : L_InfixMultiply { (uncurry Grammar.BNFC'Position (tokenLineCol $1), Grammar.InfixMultiply (tokenText $1)) }

InfixAdd :: { (Grammar.BNFC'Position, Grammar.InfixAdd) }
InfixAdd  : L_InfixAdd { (uncurry Grammar.BNFC'Position (tokenLineCol $1), Grammar.InfixAdd (tokenText $1)) }

InfixAt :: { (Grammar.BNFC'Position, Grammar.InfixAt) }
InfixAt  : L_InfixAt { (uncurry Grammar.BNFC'Position (tokenLineCol $1), Grammar.InfixAt (tokenText $1)) }

InfixCompare :: { (Grammar.BNFC'Position, Grammar.InfixCompare) }
InfixCompare  : L_InfixCompare { (uncurry Grammar.BNFC'Position (tokenLineCol $1), Grammar.InfixCompare (tokenText $1)) }

InfixAnd :: { (Grammar.BNFC'Position, Grammar.InfixAnd) }
InfixAnd  : L_InfixAnd { (uncurry Grammar.BNFC'Position (tokenLineCol $1), Grammar.InfixAnd (tokenText $1)) }

InfixOr :: { (Grammar.BNFC'Position, Grammar.InfixOr) }
InfixOr  : L_InfixOr { (uncurry Grammar.BNFC'Position (tokenLineCol $1), Grammar.InfixOr (tokenText $1)) }

InfixAssignRef :: { (Grammar.BNFC'Position, Grammar.InfixAssignRef) }
InfixAssignRef  : L_InfixAssignRef { (uncurry Grammar.BNFC'Position (tokenLineCol $1), Grammar.InfixAssignRef (tokenText $1)) }

DirectiveIdent :: { (Grammar.BNFC'Position, Grammar.DirectiveIdent) }
DirectiveIdent  : L_DirectiveIdent { (uncurry Grammar.BNFC'Position (tokenLineCol $1), Grammar.DirectiveIdent (tokenText $1)) }

UppercaseIdent :: { (Grammar.BNFC'Position, Grammar.UppercaseIdent) }
UppercaseIdent  : L_UppercaseIdent { (uncurry Grammar.BNFC'Position (tokenLineCol $1), Grammar.UppercaseIdent (tokenText $1)) }

LowercaseIdent :: { (Grammar.BNFC'Position, Grammar.LowercaseIdent) }
LowercaseIdent  : L_LowercaseIdent { (uncurry Grammar.BNFC'Position (tokenLineCol $1), Grammar.LowercaseIdent (tokenText $1)) }

Infix :: { (Grammar.BNFC'Position, Grammar.Infix) }
Infix
  : InfixOr { (fst $1, Grammar.OpOr (fst $1) (snd $1)) }
  | InfixAnd { (fst $1, Grammar.OpAnd (fst $1) (snd $1)) }
  | InfixCompare { (fst $1, Grammar.OpCompare (fst $1) (snd $1)) }
  | InfixAt { (fst $1, Grammar.OpAt (fst $1) (snd $1)) }
  | '::' { (uncurry Grammar.BNFC'Position (tokenLineCol $1), Grammar.OpAppend (uncurry Grammar.BNFC'Position (tokenLineCol $1))) }
  | InfixAdd { (fst $1, Grammar.OpAdd (fst $1) (snd $1)) }
  | '-' { (uncurry Grammar.BNFC'Position (tokenLineCol $1), Grammar.OpSubInt (uncurry Grammar.BNFC'Position (tokenLineCol $1))) }
  | '-.' { (uncurry Grammar.BNFC'Position (tokenLineCol $1), Grammar.OpSubFloat (uncurry Grammar.BNFC'Position (tokenLineCol $1))) }
  | InfixMultiply { (fst $1, Grammar.OpMul (fst $1) (snd $1)) }
  | '*' { (uncurry Grammar.BNFC'Position (tokenLineCol $1), Grammar.OpMulInt (uncurry Grammar.BNFC'Position (tokenLineCol $1))) }
  | InfixShift { (fst $1, Grammar.OpShift (fst $1) (snd $1)) }
  | InfixHash { (fst $1, Grammar.OpHash (fst $1) (snd $1)) }
  | InfixAssignRef { (fst $1, Grammar.OpAssignRef (fst $1) (snd $1)) }

Constant :: { (Grammar.BNFC'Position, Grammar.Constant) }
Constant
  : Integer { (fst $1, Grammar.CInteger (fst $1) (snd $1)) }
  | Double { (fst $1, Grammar.CDouble (fst $1) (snd $1)) }
  | Char { (fst $1, Grammar.CChar (fst $1) (snd $1)) }
  | String { (fst $1, Grammar.CString (fst $1) (snd $1)) }
  | 'false' { (uncurry Grammar.BNFC'Position (tokenLineCol $1), Grammar.CFalse (uncurry Grammar.BNFC'Position (tokenLineCol $1))) }
  | 'true' { (uncurry Grammar.BNFC'Position (tokenLineCol $1), Grammar.CTrue (uncurry Grammar.BNFC'Position (tokenLineCol $1))) }
  | '()' { (uncurry Grammar.BNFC'Position (tokenLineCol $1), Grammar.CUnit1 (uncurry Grammar.BNFC'Position (tokenLineCol $1))) }
  | '(' ')' { (uncurry Grammar.BNFC'Position (tokenLineCol $1), Grammar.CUnit2 (uncurry Grammar.BNFC'Position (tokenLineCol $1))) }
  | 'begin' 'end' { (uncurry Grammar.BNFC'Position (tokenLineCol $1), Grammar.CBegin (uncurry Grammar.BNFC'Position (tokenLineCol $1))) }

ForToDownTo :: { (Grammar.BNFC'Position, Grammar.ForToDownTo) }
ForToDownTo
  : 'to' { (uncurry Grammar.BNFC'Position (tokenLineCol $1), Grammar.ForTo (uncurry Grammar.BNFC'Position (tokenLineCol $1))) }
  | 'downto' { (uncurry Grammar.BNFC'Position (tokenLineCol $1), Grammar.ForDownTo (uncurry Grammar.BNFC'Position (tokenLineCol $1))) }

RecOptional :: { (Grammar.BNFC'Position, Grammar.RecOptional) }
RecOptional
  : {- empty -} { (Grammar.BNFC'NoPosition, Grammar.RecNo Grammar.BNFC'NoPosition) }
  | 'rec' { (uncurry Grammar.BNFC'Position (tokenLineCol $1), Grammar.RecYes (uncurry Grammar.BNFC'Position (tokenLineCol $1))) }

Expr :: { (Grammar.BNFC'Position, Grammar.Expr) }
Expr
  : Expr1 { (fst $1, (snd $1)) }
  | 'let' RecOptional ListExpr1 'in' Expr { (uncurry Grammar.BNFC'Position (tokenLineCol $1), Grammar.ELetIn (uncurry Grammar.BNFC'Position (tokenLineCol $1)) (snd $2) (snd $3) (snd $5)) }

Expr1 :: { (Grammar.BNFC'Position, Grammar.Expr) }
Expr1
  : Expr2 { (fst $1, (snd $1)) }
  | Expr2 ';' ListExpr2 { (fst $1, Grammar.ESeq (fst $1) (snd $1) (snd $3)) }
  | 'sig' Toplevel 'end' { (uncurry Grammar.BNFC'Position (tokenLineCol $1), Grammar.ModuleSignature (uncurry Grammar.BNFC'Position (tokenLineCol $1)) (snd $2)) }
  | 'struct' Toplevel 'end' { (uncurry Grammar.BNFC'Position (tokenLineCol $1), Grammar.ModuleDefinition (uncurry Grammar.BNFC'Position (tokenLineCol $1)) (snd $2)) }
  | Function ListExpr18 '->' Expr { (fst $1, Grammar.ELambda (fst $1) (snd $1) (snd $2) (snd $4)) }
  | Function ListExpr18 ':' Expr5 '->' Expr { (fst $1, Grammar.ELambdaTyped (fst $1) (snd $1) (snd $2) (snd $4) (snd $6)) }
  | Expr2 '=' Expr { (fst $1, Grammar.LetPattern (fst $1) (snd $1) (snd $3)) }
  | 'match' Expr 'with' PatternPrefixOptional ListExpr3 { (uncurry Grammar.BNFC'Position (tokenLineCol $1), Grammar.EMatch (uncurry Grammar.BNFC'Position (tokenLineCol $1)) (snd $2) (snd $4) (snd $5)) }
  | 'try' Expr 'with' PatternPrefixOptional ListExpr3 { (uncurry Grammar.BNFC'Position (tokenLineCol $1), Grammar.ETryWith (uncurry Grammar.BNFC'Position (tokenLineCol $1)) (snd $2) (snd $4) (snd $5)) }

Expr2 :: { (Grammar.BNFC'Position, Grammar.Expr) }
Expr2
  : Expr3 { (fst $1, (snd $1)) }
  | Expr3 '|' ListExpr3 { (fst $1, Grammar.ConstrOr (fst $1) (snd $1) (snd $3)) }

Expr3 :: { (Grammar.BNFC'Position, Grammar.Expr) }
Expr3
  : Expr4 { (fst $1, (snd $1)) }
  | Expr23 'of' Expr4 { (fst $1, Grammar.ConstrOf (fst $1) (snd $1) (snd $3)) }
  | Expr17 ':' Expr4 { (fst $1, Grammar.ETyped (fst $1) (snd $1) (snd $3)) }

Expr4 :: { (Grammar.BNFC'Position, Grammar.Expr) }
Expr4
  : Expr5 { (fst $1, (snd $1)) }
  | Expr5 '->' Expr4 { (fst $1, Grammar.TFunction (fst $1) (snd $1) (snd $3)) }

Expr5 :: { (Grammar.BNFC'Position, Grammar.Expr) }
Expr5
  : Expr6 { (fst $1, (snd $1)) }
  | 'if' Expr6 'then' Expr6 { (uncurry Grammar.BNFC'Position (tokenLineCol $1), Grammar.EIf (uncurry Grammar.BNFC'Position (tokenLineCol $1)) (snd $2) (snd $4)) }
  | 'if' Expr6 'then' Expr6 'else' Expr5 { (uncurry Grammar.BNFC'Position (tokenLineCol $1), Grammar.EIfElse (uncurry Grammar.BNFC'Position (tokenLineCol $1)) (snd $2) (snd $4) (snd $6)) }

Expr6 :: { (Grammar.BNFC'Position, Grammar.Expr) }
Expr6
  : Expr7 { (fst $1, (snd $1)) }
  | Expr7 InfixAssignRef Expr6 { (fst $1, Grammar.EAssignRef (fst $1) (snd $1) (snd $2) (snd $3)) }
  | Expr7 '<-' Expr6 { (fst $1, Grammar.EAssign (fst $1) (snd $1) (snd $3)) }

Expr7 :: { (Grammar.BNFC'Position, Grammar.Expr) }
Expr7
  : Expr8 { (fst $1, (snd $1)) }
  | Expr8 ',' ListExpr8 { (fst $1, Grammar.ETuple (fst $1) (snd $1) (snd $3)) }

Expr8 :: { (Grammar.BNFC'Position, Grammar.Expr) }
Expr8
  : Expr9 { (fst $1, (snd $1)) }
  | Expr9 InfixOr Expr8 { (fst $1, Grammar.EOr (fst $1) (snd $1) (snd $2) (snd $3)) }

Expr9 :: { (Grammar.BNFC'Position, Grammar.Expr) }
Expr9
  : Expr10 { (fst $1, (snd $1)) }
  | Expr10 InfixAnd Expr9 { (fst $1, Grammar.EAnd (fst $1) (snd $1) (snd $2) (snd $3)) }

Expr10 :: { (Grammar.BNFC'Position, Grammar.Expr) }
Expr10
  : Expr11 { (fst $1, (snd $1)) }
  | Expr10 InfixCompare Expr11 { (fst $1, Grammar.ECompare (fst $1) (snd $1) (snd $2) (snd $3)) }

Expr11 :: { (Grammar.BNFC'Position, Grammar.Expr) }
Expr11
  : Expr12 { (fst $1, (snd $1)) }
  | Expr12 InfixAt Expr11 { (fst $1, Grammar.EAt (fst $1) (snd $1) (snd $2) (snd $3)) }

Expr12 :: { (Grammar.BNFC'Position, Grammar.Expr) }
Expr12
  : Expr13 { (fst $1, (snd $1)) }
  | Expr13 '::' Expr12 { (fst $1, Grammar.EAppend (fst $1) (snd $1) (snd $3)) }

Expr13 :: { (Grammar.BNFC'Position, Grammar.Expr) }
Expr13
  : Expr14 { (fst $1, (snd $1)) }
  | Expr13 InfixAdd Expr14 { (fst $1, Grammar.EAdd (fst $1) (snd $1) (snd $2) (snd $3)) }
  | Expr13 '-' Expr14 { (fst $1, Grammar.ESubInt (fst $1) (snd $1) (snd $3)) }
  | Expr13 '-.' Expr14 { (fst $1, Grammar.ESubFloat (fst $1) (snd $1) (snd $3)) }

Expr14 :: { (Grammar.BNFC'Position, Grammar.Expr) }
Expr14
  : Expr15 { (fst $1, (snd $1)) }
  | Expr14 InfixMultiply Expr15 { (fst $1, Grammar.EMultiply (fst $1) (snd $1) (snd $2) (snd $3)) }
  | Expr15 '*' ListExpr15 { (fst $1, Grammar.TTuple (fst $1) (snd $1) (snd $3)) }

Expr15 :: { (Grammar.BNFC'Position, Grammar.Expr) }
Expr15
  : Expr16 { (fst $1, (snd $1)) }
  | Expr16 InfixShift Expr15 { (fst $1, Grammar.EShift (fst $1) (snd $1) (snd $2) (snd $3)) }

Expr16 :: { (Grammar.BNFC'Position, Grammar.Expr) }
Expr16
  : Expr17 { (fst $1, (snd $1)) }
  | '-' Expr17 { (uncurry Grammar.BNFC'Position (tokenLineCol $1), Grammar.ENegateInt (uncurry Grammar.BNFC'Position (tokenLineCol $1)) (snd $2)) }
  | '-.' Expr17 { (uncurry Grammar.BNFC'Position (tokenLineCol $1), Grammar.ENegateFloat (uncurry Grammar.BNFC'Position (tokenLineCol $1)) (snd $2)) }

Expr17 :: { (Grammar.BNFC'Position, Grammar.Expr) }
Expr17
  : Expr18 { (fst $1, (snd $1)) }
  | Expr18 ListExpr18 { (fst $1, Grammar.EApply (fst $1) (snd $1) (snd $2)) }

Expr18 :: { (Grammar.BNFC'Position, Grammar.Expr) }
Expr18 : Expr19 { (fst $1, (snd $1)) }

Expr19 :: { (Grammar.BNFC'Position, Grammar.Expr) }
Expr19
  : Expr20 { (fst $1, (snd $1)) }
  | Expr19 InfixHash Expr20 { (fst $1, Grammar.EHash (fst $1) (snd $1) (snd $2) (snd $3)) }

Expr20 :: { (Grammar.BNFC'Position, Grammar.Expr) }
Expr20 : Expr21 { (fst $1, (snd $1)) }

Expr21 :: { (Grammar.BNFC'Position, Grammar.Expr) }
Expr21
  : Expr22 { (fst $1, (snd $1)) }
  | Prefix Expr21 { (fst $1, Grammar.EPrefix (fst $1) (snd $1) (snd $2)) }

Expr22 :: { (Grammar.BNFC'Position, Grammar.Expr) }
Expr22
  : Expr23 { (fst $1, (snd $1)) }
  | 'begin' Expr 'end' { (uncurry Grammar.BNFC'Position (tokenLineCol $1), Grammar.EBegin (uncurry Grammar.BNFC'Position (tokenLineCol $1)) (snd $2)) }
  | 'while' Expr 'do' Expr 'done' { (uncurry Grammar.BNFC'Position (tokenLineCol $1), Grammar.EWhile (uncurry Grammar.BNFC'Position (tokenLineCol $1)) (snd $2) (snd $4)) }
  | 'for' Expr ForToDownTo Expr 'do' Expr 'done' { (uncurry Grammar.BNFC'Position (tokenLineCol $1), Grammar.EFor (uncurry Grammar.BNFC'Position (tokenLineCol $1)) (snd $2) (snd $3) (snd $4) (snd $6)) }

Expr23 :: { (Grammar.BNFC'Position, Grammar.Expr) }
Expr23
  : Expr24 { (fst $1, (snd $1)) }
  | ListOIdent { (fst $1, Grammar.Variable (fst $1) (snd $1)) }
  | '\'' OIdent { (uncurry Grammar.BNFC'Position (tokenLineCol $1), Grammar.TIdent (uncurry Grammar.BNFC'Position (tokenLineCol $1)) (snd $2)) }
  | '_' { (uncurry Grammar.BNFC'Position (tokenLineCol $1), Grammar.Blank (uncurry Grammar.BNFC'Position (tokenLineCol $1))) }
  | Constant { (fst $1, Grammar.EConstant (fst $1) (snd $1)) }
  | '{' ListField '}' { (uncurry Grammar.BNFC'Position (tokenLineCol $1), Grammar.Record (uncurry Grammar.BNFC'Position (tokenLineCol $1)) (snd $2)) }
  | '[' ListExpr2 ']' { (uncurry Grammar.BNFC'Position (tokenLineCol $1), Grammar.List (uncurry Grammar.BNFC'Position (tokenLineCol $1)) (snd $2)) }
  | '[' ']' { (uncurry Grammar.BNFC'Position (tokenLineCol $1), Grammar.Nil1 (uncurry Grammar.BNFC'Position (tokenLineCol $1))) }
  | '[]' { (uncurry Grammar.BNFC'Position (tokenLineCol $1), Grammar.Nil2 (uncurry Grammar.BNFC'Position (tokenLineCol $1))) }

Expr24 :: { (Grammar.BNFC'Position, Grammar.Expr) }
Expr24
  : '(' Expr ')' { (uncurry Grammar.BNFC'Position (tokenLineCol $1), (snd $2)) }

ListField :: { (Grammar.BNFC'Position, [Grammar.Field]) }
ListField
  : {- empty -} { (Grammar.BNFC'NoPosition, []) }
  | Field { (fst $1, (:[]) (snd $1)) }
  | Field ';' ListField { (fst $1, (:) (snd $1) (snd $3)) }

Field :: { (Grammar.BNFC'Position, Grammar.Field) }
Field
  : Expr23 '=' Expr2 { (fst $1, Grammar.EField (fst $1) (snd $1) (snd $3)) }
  | Expr23 ':' Expr4 { (fst $1, Grammar.EFieldDecl (fst $1) (snd $1) (snd $3)) }
  | 'mutable' Expr23 ':' Expr4 { (uncurry Grammar.BNFC'Position (tokenLineCol $1), Grammar.EFieldDeclMut (uncurry Grammar.BNFC'Position (tokenLineCol $1)) (snd $2) (snd $4)) }

ListExpr18 :: { (Grammar.BNFC'Position, [Grammar.Expr]) }
ListExpr18
  : Expr18 { (fst $1, (:[]) (snd $1)) }
  | Expr18 ListExpr18 { (fst $1, (:) (snd $1) (snd $2)) }

ListExpr15 :: { (Grammar.BNFC'Position, [Grammar.Expr]) }
ListExpr15
  : Expr15 { (fst $1, (:[]) (snd $1)) }
  | Expr15 '*' ListExpr15 { (fst $1, (:) (snd $1) (snd $3)) }

ListExpr8 :: { (Grammar.BNFC'Position, [Grammar.Expr]) }
ListExpr8
  : Expr8 { (fst $1, (:[]) (snd $1)) }
  | Expr8 ',' ListExpr8 { (fst $1, (:) (snd $1) (snd $3)) }

ListExpr3 :: { (Grammar.BNFC'Position, [Grammar.Expr]) }
ListExpr3
  : Expr3 { (fst $1, (:[]) (snd $1)) }
  | Expr3 '|' ListExpr3 { (fst $1, (:) (snd $1) (snd $3)) }

ListExpr2 :: { (Grammar.BNFC'Position, [Grammar.Expr]) }
ListExpr2
  : Expr2 { (fst $1, (:[]) (snd $1)) }
  | Expr2 ';' ListExpr2 { (fst $1, (:) (snd $1) (snd $3)) }

ListExpr1 :: { (Grammar.BNFC'Position, [Grammar.Expr]) }
ListExpr1
  : Expr1 { (fst $1, (:[]) (snd $1)) }
  | Expr1 'and' ListExpr1 { (fst $1, (:) (snd $1) (snd $3)) }

Function :: { (Grammar.BNFC'Position, Grammar.Function) }
Function
  : 'fun' { (uncurry Grammar.BNFC'Position (tokenLineCol $1), Grammar.Fun1 (uncurry Grammar.BNFC'Position (tokenLineCol $1))) }
  | 'function' { (uncurry Grammar.BNFC'Position (tokenLineCol $1), Grammar.Fun2 (uncurry Grammar.BNFC'Position (tokenLineCol $1))) }

PatternPrefixOptional :: { (Grammar.BNFC'Position, Grammar.PatternPrefixOptional) }
PatternPrefixOptional
  : {- empty -} { (Grammar.BNFC'NoPosition, Grammar.PatternPrefixNo Grammar.BNFC'NoPosition) }
  | '|' { (uncurry Grammar.BNFC'Position (tokenLineCol $1), Grammar.PatternPrefixYes (uncurry Grammar.BNFC'Position (tokenLineCol $1))) }

ListStatement :: { (Grammar.BNFC'Position, [Grammar.Statement]) }
ListStatement
  : {- empty -} { (Grammar.BNFC'NoPosition, []) }
  | Statement ListStatement { (fst $1, (:) (snd $1) (snd $2)) }

Statement :: { (Grammar.BNFC'Position, Grammar.Statement) }
Statement
  : 'val' Expr3 { (uncurry Grammar.BNFC'Position (tokenLineCol $1), Grammar.Signature (uncurry Grammar.BNFC'Position (tokenLineCol $1)) (snd $2)) }
  | 'external' Expr1 { (uncurry Grammar.BNFC'Position (tokenLineCol $1), Grammar.External (uncurry Grammar.BNFC'Position (tokenLineCol $1)) (snd $2)) }
  | 'type' Expr4 '=' PatternPrefixOptional ListExpr3 { (uncurry Grammar.BNFC'Position (tokenLineCol $1), Grammar.Typedef (uncurry Grammar.BNFC'Position (tokenLineCol $1)) (snd $2) (snd $4) (snd $5)) }
  | 'exception' Expr3 { (uncurry Grammar.BNFC'Position (tokenLineCol $1), Grammar.Exception (uncurry Grammar.BNFC'Position (tokenLineCol $1)) (snd $2)) }
  | 'module' Expr1 { (uncurry Grammar.BNFC'Position (tokenLineCol $1), Grammar.Module (uncurry Grammar.BNFC'Position (tokenLineCol $1)) (snd $2)) }
  | 'module' 'type' Expr1 { (uncurry Grammar.BNFC'Position (tokenLineCol $1), Grammar.ModuleType (uncurry Grammar.BNFC'Position (tokenLineCol $1)) (snd $3)) }
  | 'let' RecOptional ListExpr1 { (uncurry Grammar.BNFC'Position (tokenLineCol $1), Grammar.Definition (uncurry Grammar.BNFC'Position (tokenLineCol $1)) (snd $2) (snd $3)) }
  | 'let' RecOptional ListExpr1 'in' Expr { (uncurry Grammar.BNFC'Position (tokenLineCol $1), Grammar.SLetIn (uncurry Grammar.BNFC'Position (tokenLineCol $1)) (snd $2) (snd $3) (snd $5)) }
  | ';;' Expr1 { (uncurry Grammar.BNFC'Position (tokenLineCol $1), Grammar.Expression (uncurry Grammar.BNFC'Position (tokenLineCol $1)) (snd $2)) }
  | '#' OIdent Expr17 { (uncurry Grammar.BNFC'Position (tokenLineCol $1), Grammar.Directive1 (uncurry Grammar.BNFC'Position (tokenLineCol $1)) (snd $2) (snd $3)) }
  | DirectiveIdent Expr17 { (fst $1, Grammar.Directive2 (fst $1) (snd $1) (snd $2)) }
  | Statement ';;' { (fst $1, Grammar.EndStmt (fst $1) (snd $1)) }

Toplevel :: { (Grammar.BNFC'Position, Grammar.Toplevel) }
Toplevel
  : ListStatement { (fst $1, Grammar.Toplevel1 (fst $1) (snd $1)) }
  | Expr1 ListStatement { (fst $1, Grammar.Toplevel2 (fst $1) (snd $1) (snd $2)) }

ListOIdent :: { (Grammar.BNFC'Position, [Grammar.OIdent]) }
ListOIdent
  : OIdent { (fst $1, (:[]) (snd $1)) }
  | OIdent '.' ListOIdent { (fst $1, (:) (snd $1) (snd $3)) }

OIdent :: { (Grammar.BNFC'Position, Grammar.OIdent) }
OIdent
  : UppercaseIdent { (fst $1, Grammar.IUppercase (fst $1) (snd $1)) }
  | LowercaseIdent { (fst $1, Grammar.ILowercase (fst $1) (snd $1)) }
  | '(' Prefix ')' { (uncurry Grammar.BNFC'Position (tokenLineCol $1), Grammar.IPrefix (uncurry Grammar.BNFC'Position (tokenLineCol $1)) (snd $2)) }
  | '(' Infix ')' { (uncurry Grammar.BNFC'Position (tokenLineCol $1), Grammar.IInfix (uncurry Grammar.BNFC'Position (tokenLineCol $1)) (snd $2)) }

{

type Err = Either String

happyError :: [Token] -> Err a
happyError ts = Left $
  "syntax error at " ++ tokenPos ts ++
  case ts of
    []      -> []
    [Err _] -> " due to lexer error"
    t:_     -> " before `" ++ (prToken t) ++ "'"

myLexer :: String -> [Token]
myLexer = tokens

-- Entrypoints

pToplevel :: [Token] -> Err Grammar.Toplevel
pToplevel = fmap snd . pToplevel_internal
}

