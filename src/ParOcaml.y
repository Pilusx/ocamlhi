-- This Happy file was machine-generated by the BNF converter
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
module ParOcaml where
import Grammar
import LexOcaml
import ErrM

}

%name pProg Prog
-- no lexer declaration
%monad { Err } { thenM } { returnM }
%tokentype {Token}
%token
  '#' { PT _ (TS _ 1) }
  '(' { PT _ (TS _ 2) }
  ')' { PT _ (TS _ 3) }
  '*' { PT _ (TS _ 4) }
  ',' { PT _ (TS _ 5) }
  '-' { PT _ (TS _ 6) }
  '->' { PT _ (TS _ 7) }
  '.' { PT _ (TS _ 8) }
  ':' { PT _ (TS _ 9) }
  '::' { PT _ (TS _ 10) }
  ';' { PT _ (TS _ 11) }
  ';;' { PT _ (TS _ 12) }
  '<-' { PT _ (TS _ 13) }
  '=' { PT _ (TS _ 14) }
  'T' { PT _ (TS _ 15) }
  '_' { PT _ (TS _ 16) }
  '__typeof__' { PT _ (TS _ 17) }
  '`' { PT _ (TS _ 18) }
  'begin' { PT _ (TS _ 19) }
  'bool' { PT _ (TS _ 20) }
  'char' { PT _ (TS _ 21) }
  'do' { PT _ (TS _ 22) }
  'done' { PT _ (TS _ 23) }
  'downto' { PT _ (TS _ 24) }
  'else' { PT _ (TS _ 25) }
  'enable' { PT _ (TS _ 26) }
  'end' { PT _ (TS _ 27) }
  'exception' { PT _ (TS _ 28) }
  'external' { PT _ (TS _ 29) }
  'false' { PT _ (TS _ 30) }
  'float' { PT _ (TS _ 31) }
  'for' { PT _ (TS _ 32) }
  'fun' { PT _ (TS _ 33) }
  'function' { PT _ (TS _ 34) }
  'if' { PT _ (TS _ 35) }
  'in' { PT _ (TS _ 36) }
  'int' { PT _ (TS _ 37) }
  'let' { PT _ (TS _ 38) }
  'match' { PT _ (TS _ 39) }
  'module' { PT _ (TS _ 40) }
  'mutable' { PT _ (TS _ 41) }
  'of' { PT _ (TS _ 42) }
  'raise' { PT _ (TS _ 43) }
  'rec' { PT _ (TS _ 44) }
  'sig' { PT _ (TS _ 45) }
  'string' { PT _ (TS _ 46) }
  'struct' { PT _ (TS _ 47) }
  'then' { PT _ (TS _ 48) }
  'to' { PT _ (TS _ 49) }
  'true' { PT _ (TS _ 50) }
  'type' { PT _ (TS _ 51) }
  'unit' { PT _ (TS _ 52) }
  'use' { PT _ (TS _ 53) }
  'val' { PT _ (TS _ 54) }
  'while' { PT _ (TS _ 55) }
  'with' { PT _ (TS _ 56) }
  '{' { PT _ (TS _ 57) }
  '|' { PT _ (TS _ 58) }
  '}' { PT _ (TS _ 59) }

L_quoted { PT _ (TL $$) }
L_ident  { PT _ (TV $$) }
L_integ  { PT _ (TI $$) }
L_doubl  { PT _ (TD $$) }
L_charac { PT _ (TC $$) }
L_InfixSymbol { PT _ (T_InfixSymbol $$) }
L_PrefixSymbol { PT _ (T_PrefixSymbol $$) }
L_InfixSymbolOther { PT _ (T_InfixSymbolOther $$) }
L_PrefixSymbolOther { PT _ (T_PrefixSymbolOther $$) }


%%

String  :: { String }  : L_quoted {  $1 }
Ident   :: { Ident }   : L_ident  { Ident $1 }
Integer :: { Integer } : L_integ  { (read ( $1)) :: Integer }
Double  :: { Double }  : L_doubl  { (read ( $1)) :: Double }
Char    :: { Char }    : L_charac { (read ( $1)) :: Char }
InfixSymbol    :: { InfixSymbol} : L_InfixSymbol { InfixSymbol ($1)}
PrefixSymbol    :: { PrefixSymbol} : L_PrefixSymbol { PrefixSymbol ($1)}
InfixSymbolOther    :: { InfixSymbolOther} : L_InfixSymbolOther { InfixSymbolOther ($1)}
PrefixSymbolOther    :: { PrefixSymbolOther} : L_PrefixSymbolOther { PrefixSymbolOther ($1)}

Prog :: { Prog }
Prog : ListStatement { Grammar.Prog1 $1 }
ListStatement :: { [Statement] }
ListStatement : {- empty -} { [] }
              | Statement { (:[]) $1 }
              | Statement ';;' ListStatement { (:) $1 $3 }
Statement :: { Statement }
Statement : '#' 'use' FileName { Grammar.SDirective $3 }
          | '#' 'enable' String { Grammar.SEnable $3 }
          | Expression { Grammar.SExpression $1 }
          | Expression '::' Type { Grammar.SExpressionWithType $1 $3 }
          | Signature { Grammar.SSignature $1 }
          | 'type' Type '=' TypedefDefinition { Grammar.STypedef $2 $4 }
          | ModuleContent { Grammar.SModuleContent $1 }
          | 'module' 'type' Ident '=' 'sig' ListSignature 'end' { Grammar.SModuleSignature $3 $6 }
          | ModuleName '=' 'struct' ListModuleContent 'end' { Grammar.SModuleDefinition $1 $4 }
TypedefDefinition :: { TypedefDefinition }
TypedefDefinition : ListConstructor { Grammar.TypedefConstructors $1 }
                  | '{' ListRecordField '}' { Grammar.TypedefRecords $2 }
Expression :: { Expression }
Expression : Constant { Grammar.EConst $1 }
           | String { Grammar.EString $1 }
           | Variable { Grammar.EVar $1 }
           | PrefixOp Expression { Grammar.EOp1 $1 $2 }
           | '(' Expression InfixOp Expression ')' { Grammar.EOp2 $2 $3 $4 }
           | '{' ListLabeledStatement '}' { Grammar.ERecord $2 }
           | 'if' Expression 'then' '{' Expression '}' 'else' '{' Expression '}' { Grammar.EIfThenElse $2 $5 $9 }
           | 'match' ListSimpleVariable 'with' '(' ListMatching ')' { Grammar.EMatch $2 $5 }
           | '__typeof__' Expression { Grammar.ETypeOf $2 }
           | Definition 'in' Expression { Grammar.ELocalDefinition $1 $3 }
           | 'begin' ListSequencingExpression 'end' { Grammar.EStack $2 }
           | 'for' Variable '=' Expression ForIterationType Expression 'do' ListSequencingExpression 'done' { Grammar.EFor $2 $4 $5 $6 $8 }
           | 'while' Expression 'do' ListSequencingExpression 'done' { Grammar.EWhile $2 $4 }
           | Variable '(' ListExpression ')' { Grammar.EFunctionCall $1 $3 }
           | Variable 'rec' '(' ListExpression ';' Expression ')' { Grammar.ERecursiveFunctionCall $1 $4 $6 }
           | FunctionPrefix Matching { Grammar.ELambda $1 $2 }
           | 'raise' '(' ExceptionName Expression ')' { Grammar.ERaise $3 $4 }
RecursivePrefix :: { RecursivePrefix }
RecursivePrefix : {- empty -} { Grammar.RecNo }
                | 'rec' { Grammar.RecYes }
Definition :: { Definition }
Definition : 'let' RecursivePrefix ListVariable '=' Expression { Grammar.SValue $2 (reverse $3) $5 }
           | 'external' Variable ':' Type '=' String { Grammar.SExternal $2 $4 $6 }
ListSequencingExpression :: { [SequencingExpression] }
ListSequencingExpression : SequencingExpression { (:[]) $1 }
                         | SequencingExpression ';' ListSequencingExpression { (:) $1 $3 }
SequencingExpression :: { SequencingExpression }
SequencingExpression : Expression { Grammar.ESeq $1 }
                     | Variable '<-' Expression { Grammar.EAssign $1 $3 }
ForIterationType :: { ForIterationType }
ForIterationType : 'to' { Grammar.ForTo }
                 | 'downto' { Grammar.ForDownto }
ListExpression :: { [Expression] }
ListExpression : {- empty -} { [] }
               | Expression { (:[]) $1 }
               | Expression ',' ListExpression { (:) $1 $3 }
ListLabeledStatement :: { [LabeledStatement] }
ListLabeledStatement : {- empty -} { [] }
                     | LabeledStatement { (:[]) $1 }
                     | LabeledStatement ';' ListLabeledStatement { (:) $1 $3 }
LabeledStatement :: { LabeledStatement }
LabeledStatement : Variable '=' Expression { Grammar.SLabeled $1 $3 }
                 | Variable 'of' Type '=' Expression { Grammar.SLabeledTyped $1 $3 $5 }
FunctionPrefix :: { FunctionPrefix }
FunctionPrefix : 'function' { Grammar.FunctionPrefix1 }
               | 'fun' { Grammar.FunctionPrefix2 }
ExceptionName :: { ExceptionName }
ExceptionName : Ident { Grammar.NException $1 }
ModuleContent :: { ModuleContent }
ModuleContent : 'exception' ExceptionName 'of' Type { Grammar.SExceptionDefinition $2 $4 }
              | Definition { Grammar.SDefinition $1 }
ListConstructor :: { [Constructor] }
ListConstructor : Constructor { (:[]) $1 }
                | Constructor '|' ListConstructor { (:) $1 $3 }
Constructor :: { Constructor }
Constructor : Ident { Grammar.ConstructorEps $1 }
            | Ident 'of' Type { Grammar.ConstructorType $1 $3 }
TypeConst :: { TypeConst }
TypeConst : 'bool' { Grammar.TBool }
          | 'int' { Grammar.TInt }
          | 'char' { Grammar.TChar }
          | 'float' { Grammar.TFloat }
          | 'string' { Grammar.TString }
          | 'unit' { Grammar.TUnit }
TypeConstr :: { TypeConstr }
TypeConstr : Ident { Grammar.TConstr $1 }
Type2 :: { Type }
Type2 : TypeConst { Grammar.T1Const $1 }
      | '`' Ident { Grammar.TIdent $2 }
      | TypeConstr { Grammar.TAlias $1 }
      | Type2 TypeConstr { Grammar.TParameterized1 $1 $2 }
      | '(' TypeParameters ')' TypeConstr { Grammar.TParameterizedN $2 $4 }
      | '(' Type ')' { $2 }
TypeParameters :: { TypeParameters }
TypeParameters : Type ',' Type { Grammar.TParameters2 $1 $3 }
               | Type ',' TypeParameters { Grammar.TParametersN $1 $3 }
ListType2 :: { [Type] }
ListType2 : Type2 { (:[]) $1 } | Type2 '*' ListType2 { (:) $1 $3 }
Type1 :: { Type }
Type1 : ListType2 { Grammar.TTuple $1 }
Type :: { Type }
Type : Type1 { $1 } | Type1 '->' Type { Grammar.TFunction $1 $3 }
ListSignature :: { [Signature] }
ListSignature : Signature { (:[]) $1 }
              | Signature ListSignature { (:) $1 $2 }
Signature :: { Signature }
Signature : 'val' Variable 'of' Type { Grammar.Signature1 $2 $4 }
Mutable :: { Mutable }
Mutable : {- empty -} { Grammar.MutableNo }
        | 'mutable' { Grammar.MutableYes }
ListRecordField :: { [RecordField] }
ListRecordField : RecordField { (:[]) $1 }
                | RecordField ';' ListRecordField { (:) $1 $3 }
RecordField :: { RecordField }
RecordField : Mutable Ident ':' Type { Grammar.TRecordField $1 $2 $4 }
InfixOp :: { InfixOp }
InfixOp : InfixSymbol { Grammar.InfixOp1 $1 }
        | InfixSymbolOther { Grammar.InfixOp2 $1 }
        | '-' { Grammar.InfixOpSub }
        | '*' { Grammar.InfixOpMul }
        | '<-' { Grammar.InfixOpAssign }
PrefixOp :: { PrefixOp }
PrefixOp : PrefixSymbol { Grammar.PrefixOp1 $1 }
         | PrefixSymbolOther { Grammar.PrefixOp2 $1 }
         | '-' { Grammar.PrefixOpMinus }
OperatorName :: { OperatorName }
OperatorName : PrefixSymbol { Grammar.OpNamePrefix $1 }
             | InfixOp { Grammar.OpNameInfix $1 }
TupleConstr :: { TupleConstr }
TupleConstr : 'T' { Grammar.T }
Boolean :: { Boolean }
Boolean : 'true' { Grammar.ETrue } | 'false' { Grammar.EFalse }
Constant :: { Constant }
Constant : Boolean { Grammar.EBool $1 }
         | Integer { Grammar.EInt $1 }
         | Double { Grammar.EFloat $1 }
         | Char { Grammar.EChar $1 }
ListVariable :: { [Variable] }
ListVariable : {- empty -} { [] }
             | ListVariable Variable { flip (:) $1 $2 }
Variable :: { Variable }
Variable : SimpleVariable { Grammar.VSimple $1 }
         | TupleConstr { Grammar.VOpTuple $1 }
         | '(' OperatorName ')' { Grammar.VOp $2 }
ListSimpleVariable :: { [SimpleVariable] }
ListSimpleVariable : {- empty -} { [] }
                   | SimpleVariable { (:[]) $1 }
                   | SimpleVariable ',' ListSimpleVariable { (:) $1 $3 }
SimpleVariable :: { SimpleVariable }
SimpleVariable : ListIdent { Grammar.VVariable $1 }
               | '_' { Grammar.VBlank }
ListIdent :: { [Ident] }
ListIdent : Ident { (:[]) $1 } | Ident '.' ListIdent { (:) $1 $3 }
FileName :: { FileName }
FileName : String { Grammar.NFile $1 }
ModuleName :: { ModuleName }
ModuleName : 'module' Ident { Grammar.SModuleName0 $2 }
           | 'module' Ident ':' Ident { Grammar.SModuleName1 $2 $4 }
ListModuleContent :: { [ModuleContent] }
ListModuleContent : {- empty -} { [] }
                  | ModuleContent { (:[]) $1 }
                  | ModuleContent ';;' ListModuleContent { (:) $1 $3 }
Matching :: { Matching }
Matching : ListExpression '->' Expression { Grammar.Matching1 $1 $3 }
ListMatching :: { [Matching] }
ListMatching : Matching { (:[]) $1 }
             | Matching '|' ListMatching { (:) $1 $3 }
{

returnM :: a -> Err a
returnM = return

thenM :: Err a -> (a -> Err b) -> Err b
thenM = (>>=)

happyError :: [Token] -> Err a
happyError ts =
  Bad $ "syntax error at " ++ tokenPos ts ++ 
  case ts of
    [] -> []
    [Err _] -> " due to lexer error"
    t:_ -> " before `" ++ id(prToken t) ++ "'"

myLexer = tokens
}

